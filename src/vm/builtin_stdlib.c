#include "../../include/builtin_stdlib.h"
#include <string.h>
#include <stdio.h>
#include <sys/stat.h>

const EmbeddedModule embeddedStdlib[] = {
    {"std/math.orus", "pub const PI: f64 = 3.141592653589793\npub const E: f64 = 2.718281828459045\npub const TAU: f64 = 6.283185307179586\n\npub fn abs(x: f64) -> f64 {\n    if x < 0.0 {\n        return -x\n    }\n    return x\n}\n\npub fn clamp(x: f64, min_val: f64, max_val: f64) -> f64 {\n    if x < min_val {\n        return min_val\n    }\n    if x > max_val {\n        return max_val\n    }\n    return x\n}\n\npub fn pow(base: f64, exponent: i32) -> f64 {\n    let mut b = base\n    let mut e = exponent\n    let mut result: f64 = 1.0\n    if e < 0 {\n        b = 1.0 / b\n        e = -e\n    }\n    while e > 0 {\n        if (e & 1) == 1 {\n            result = result * b\n        }\n        e = e >> 1\n        b = b * b\n    }\n    return result\n}\n\npub fn sqrt(x: f64) -> f64 {\n    if x <= 0.0 {\n        return 0.0\n    }\n    let mut guess = x / 2.0\n    let mut last = 0.0\n    while abs(guess - last) > 0.0000001 {\n        last = guess\n        guess = (guess + x / guess) / 2.0\n    }\n    return guess\n}\n\npub fn floor(x: f64) -> i32 {\n    let i: i32 = x as i32\n    if x < 0.0 and (x != (i as f64)) {\n        return i - 1\n    }\n    return i\n}\n\npub fn ceil(x: f64) -> i32 {\n    let i: i32 = x as i32\n    if x > 0.0 and (x != (i as f64)) {\n        return i + 1\n    }\n    return i\n}\n\npub fn round(x: f64) -> i32 {\n    return floor(x + 0.5)\n}\n\npub fn sign(x: f64) -> i32 {\n    if x > 0.0 {\n        return 1\n    }\n    if x < 0.0 {\n        return -1\n    }\n    return 0\n}\n\npub fn average(values: [f64]) -> f64 {\n    if len(values) == 0 {\n        return 0.0\n    }\n    return sum(values) / (len(values) as f64)\n}\n\npub fn median(values: [f64]) -> f64 {\n    if len(values) == 0 {\n        return 0.0\n    }\n    let sortedVals = sorted(values)\n    let mid = len(sortedVals) / 2\n    if (len(sortedVals) & 1) == 1 {\n        return sortedVals[mid]\n    }\n    return (sortedVals[mid - 1] + sortedVals[mid]) / 2.0\n}\n\npub fn mod(a: i32, b: i32) -> i32 {\n    let r = a % b\n    if r < 0 {\n        return r + b\n    }\n    return r\n}\n"},
    {"std/datetime.orus", "// Standard datetime utilities inspired by Python\n\nstruct Date {\n    year: i32,\n    month: i32,\n    day: i32,\n}\n\nstruct Time {\n    hour: i32,\n    minute: i32,\n    second: i32,\n    microsecond: i32,\n}\n\nstruct DateTime {\n    date: Date,\n    time: Time,\n}\n\nstruct TimeDelta {\n    seconds: i64,\n}\n\nfn is_leap_year(year: i32) -> bool {\n    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) {\n        return true\n    }\n    return false\n}\n\nfn days_in_month(year: i32, month: i32) -> i32 {\n    let days: [i32; 12] = [31,28,31,30,31,30,31,31,30,31,30,31]\n    let d = days[month - 1]\n    if month == 2 and is_leap_year(year) {\n        return 29\n    }\n    return d\n}\n\n// Convert a DateTime to seconds since the Unix epoch\npub fn timestamp(dt: DateTime) -> f64 {\n    let mut days: i64 = 0\n    let mut y: i32 = 1970\n    while y < dt.date.year {\n        if is_leap_year(y) {\n            days = days + 366\n        } else {\n            days = days + 365\n        }\n        y = y + 1\n    }\n    let mut m: i32 = 1\n    while m < dt.date.month {\n        days = days + (days_in_month(dt.date.year, m) as i64)\n        m = m + 1\n    }\n    days = days + (dt.date.day - 1)\n    let secs: i64 = days * 86400 + (dt.time.hour as i64) * 3600 + (dt.time.minute as i64) * 60 + dt.time.second as i64\n    return (secs as f64) + (dt.time.microsecond as f64) / 1000000.0\n}\n\n// Build a DateTime from a Unix timestamp (seconds since epoch)\npub fn from_timestamp(ts: f64) -> DateTime {\n    let mut seconds: i64 = ts as i64\n    let frac: f64 = ts - (seconds as f64)\n    let micro: i32 = (frac * 1000000.0) as i32\n    let second: i32 = (seconds % 60) as i32\n    let minute: i32 = ((seconds / 60) % 60) as i32\n    let hour: i32 = ((seconds / 3600) % 24) as i32\n    let mut days: i64 = seconds / 86400\n    let mut year: i32 = 1970\n    while true {\n        let mut year_days: i64 = 365 as i64\n        if is_leap_year(year) {\n            year_days = 366 as i64\n        }\n        if days >= year_days {\n            days = days - year_days\n            year = year + 1\n        } else {\n            break\n        }\n    }\n    let mut month: i32 = 1\n    while true {\n        let dim: i64 = days_in_month(year, month) as i64\n        if days >= dim {\n            days = days - dim\n            month = month + 1\n        } else {\n            break\n        }\n    }\n    let day: i32 = (days + 1) as i32\n    return DateTime{\n        date: Date{ year: year, month: month, day: day },\n        time: Time{ hour: hour, minute: minute, second: second, microsecond: micro },\n    }\n}\n\npub fn now() -> DateTime {\n    return from_timestamp(timestamp() as f64)\n}\n\npub fn utcnow() -> DateTime {\n    return from_timestamp(timestamp() as f64)\n}\n\nfn pad2(n: i32) -> string {\n    if n < 10 {\n        return \"0\" + n\n    }\n    return \"\" + n\n}\n\nfn pad4(n: i32) -> string {\n    if n < 10 {\n        return \"000\" + n\n    }\n    if n < 100 {\n        return \"00\" + n\n    }\n    if n < 1000 {\n        return \"0\" + n\n    }\n    return \"\" + n\n}\n\nfn pad6(n: i32) -> string {\n    if n < 10 {\n        return \"00000\" + n\n    }\n    if n < 100 {\n        return \"0000\" + n\n    }\n    if n < 1000 {\n        return \"000\" + n\n    }\n    if n < 10000 {\n        return \"00\" + n\n    }\n    if n < 100000 {\n        return \"0\" + n\n    }\n    return \"\" + n\n}\n\n// Basic strftime style formatting supporting %Y %m %d %H %M %S\npub fn format(dt: DateTime, fmt: string) -> string {\n    let mut out = \"\"\n    let mut i: i32 = 0\n    while i < len(fmt) {\n        let ch = substring(fmt, i, 1)\n        if ch == \"%\" {\n            let code = substring(fmt, i + 1, 1)\n            if code == \"Y\" {\n                out = out + pad4(dt.date.year)\n            } else {\n                if code == \"m\" {\n                    out = out + pad2(dt.date.month)\n                } else {\n                    if code == \"d\" {\n                        out = out + pad2(dt.date.day)\n                    } else {\n                        if code == \"H\" {\n                            out = out + pad2(dt.time.hour)\n                        } else {\n                            if code == \"M\" {\n                                out = out + pad2(dt.time.minute)\n                            } else {\n                                if code == \"S\" {\n                                    out = out + pad2(dt.time.second)\n                                } else {\n                                    if code == \"f\" {\n                                        out = out + pad6(dt.time.microsecond)\n                                    } else {\n                                        out = out + code\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            i = i + 2\n        } else {\n            out = out + ch\n            i = i + 1\n        }\n    }\n    return out\n}\n\n// Parse a datetime string according to the given format\npub fn parse(text: string, fmt: string) -> DateTime {\n    let mut year: i32 = 1970\n    let mut month: i32 = 1\n    let mut day: i32 = 1\n    let mut hour: i32 = 0\n    let mut minute: i32 = 0\n    let mut second: i32 = 0\n    let mut micro: i32 = 0\n    let mut i_fmt: i32 = 0\n    let mut i_txt: i32 = 0\n    while i_fmt < len(fmt) {\n        let ch = substring(fmt, i_fmt, 1)\n        if ch == \"%\" {\n            let code = substring(fmt, i_fmt + 1, 1)\n            if code == \"Y\" {\n                let part = substring(text, i_txt, 4)\n                year = int(part)\n                i_txt = i_txt + 4\n            } else {\n                if code == \"m\" {\n                    let part = substring(text, i_txt, 2)\n                    month = int(part)\n                    i_txt = i_txt + 2\n                } else {\n                    if code == \"d\" {\n                        let part = substring(text, i_txt, 2)\n                        day = int(part)\n                        i_txt = i_txt + 2\n                    } else {\n                        if code == \"H\" {\n                            let part = substring(text, i_txt, 2)\n                            hour = int(part)\n                            i_txt = i_txt + 2\n                        } else {\n                            if code == \"M\" {\n                                let part = substring(text, i_txt, 2)\n                                minute = int(part)\n                                i_txt = i_txt + 2\n                            } else {\n                                if code == \"S\" {\n                                    let part = substring(text, i_txt, 2)\n                                    second = int(part)\n                                    i_txt = i_txt + 2\n                                } else {\n                                    if code == \"f\" {\n                                        let part = substring(text, i_txt, 6)\n                                        micro = int(part)\n                                        i_txt = i_txt + 6\n                                    } else {\n                                        i_txt = i_txt + 1\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            i_fmt = i_fmt + 2\n        } else {\n            i_fmt = i_fmt + 1\n            i_txt = i_txt + 1\n        }\n    }\n    return DateTime{\n        date: Date{ year: year, month: month, day: day },\n        time: Time{ hour: hour, minute: minute, second: second, microsecond: micro },\n    }\n}\n\npub fn date(dt: DateTime) -> Date {\n    return dt.date\n}\n\npub fn time(dt: DateTime) -> Time {\n    return dt.time\n}\n\npub fn to_string(dt: DateTime) -> string {\n    let base = format(dt, \"%Y-%m-%d %H:%M:%S\")\n    if dt.time.microsecond != 0 {\n        return base + \".\" + pad6(dt.time.microsecond)\n    }\n    return base\n}\n\npub fn DateTime_to_string(dt: DateTime) -> string {\n    return to_string(dt)\n}\n\nimpl DateTime {\n    fn to_string(self) -> string {\n        return to_string(self)\n    }\n}\n\n"},
    {"std/random.orus", "use std::datetime\n\n// Linear Congruential Generator state\nstatic mut SEED: u64 = 123456789u\n\nfn rand_u64() -> u64 {\n    // Update the global seed using LCG parameters\n    SEED = ((SEED as i64 * 6364136223846793005 + 1) as u64)\n    return SEED\n}\n\n// Set the seed for reproducible sequences\npub fn set_seed(seed: u64) {\n    SEED = seed\n}\n\n// Return a float in the range [0.0, 1.0)\npub fn random() -> f64 {\n    // Divide by 2^64-1 to map to [0,1)\n    return (rand_u64() as f64) / 18446744073709551615.0\n}\n\n// Return an integer in [min, max]\npub fn randint(min: i32, max: i32) -> i32 {\n    let r: f64 = random()\n    let range: f64 = (max - min + 1) as f64\n    let offset: i32 = (r * range) as i32\n    return min + offset\n}\n\n// Return a float in [a, b]\npub fn uniform(a: f64, b: f64) -> f64 {\n    return a + (b - a) * random()\n}\n\n// Choose a random element from the array\npub fn choice<T>(arr: [T]) -> T {\n    let i = randint(0, len(arr) - 1)\n    return arr[i]\n}\n\n// Shuffle the array in-place using Fisher-Yates\npub fn shuffle<T>(arr: [T]) {\n    let n = len(arr)\n    for i in 0..n {\n        let j = randint(i, n - 1)\n        let temp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = temp\n    }\n}\n\n// Return k unique elements sampled from the array\npub fn sample<T>(arr: [T], k: i32) -> [T] {\n    let copy: [T; 0] = arr[..]\n    shuffle(copy)\n    return copy[0..k]\n}\n\n// TODO: additional distributions like gauss require math.log/cos/sin\n"},
};
const int embeddedStdlibCount = sizeof(embeddedStdlib)/sizeof(EmbeddedModule);

const char* getEmbeddedModule(const char* name){
    for(int i=0;i<embeddedStdlibCount;i++){
        if(strcmp(embeddedStdlib[i].name,name)==0) return embeddedStdlib[i].source;
    }
    return NULL;
}

static void ensure_dir(const char* path){
    char tmp[512];
    strncpy(tmp,path,sizeof(tmp)-1);
    tmp[sizeof(tmp)-1]=0;
    for(char* p=tmp+1; *p; p++){ if(*p=='/'){ *p=0; mkdir(tmp,0755); *p='/'; } }
    mkdir(tmp,0755);
}

void dumpEmbeddedStdlib(const char* dir){
    char full[512];
    for(int i=0;i<embeddedStdlibCount;i++){
        snprintf(full,sizeof(full),"%s/%s",dir,embeddedStdlib[i].name);
        char* slash=strrchr(full,'/');
        if(slash){ *slash=0; ensure_dir(full); *slash='/'; } else { ensure_dir(full); }
        FILE* f=fopen(full,"w"); if(f){ fputs(embeddedStdlib[i].source,f); fclose(f); }
    }
}
