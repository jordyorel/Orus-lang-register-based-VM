#include "../../include/builtin_stdlib.h"
#include <string.h>
#include <stdio.h>
#include <sys/stat.h>

const EmbeddedModule embeddedStdlib[] = {
    {"std/collections.orus", "pub struct Entry<K, V> {\n    key: K,\n    value: V,\n}\n\npub struct Map<K, V> {\n    items: [Entry<K, V>]\n}\n\npub struct MapIterator<K, V> {\n    items: [Entry<K, V>]\n    index: i32\n}\n\npub fn map_new<K, V>() -> Map<K, V> {\n    return Map<K, V>{ items: [] }\n}\n\npub fn map_put<K: Comparable, V>(map: Map<K, V>, key: K, value: V) {\n    for i in 0..len(map.items) {\n        if map.items[i].key == key {\n            map.items[i].value = value\n            return\n        }\n    }\n    map.items.push(Entry<K, V>{ key: key, value: value })\n}\n\npub fn map_get<K: Comparable, V>(map: Map<K, V>, key: K, default: V) -> V {\n    for i in 0..len(map.items) {\n        if map.items[i].key == key {\n            return map.items[i].value\n        }\n    }\n    return default\n}\n\npub fn map_contains<K: Comparable, V>(map: Map<K, V>, key: K) -> bool {\n    for i in 0..len(map.items) {\n        if map.items[i].key == key {\n            return true\n        }\n    }\n    return false\n}\n\npub fn map_remove<K: Comparable, V>(map: Map<K, V>, key: K) -> bool {\n    for i in 0..len(map.items) {\n        if map.items[i].key == key {\n            let idx = i\n            for j in idx+1..len(map.items) {\n                map.items[j-1] = map.items[j]\n            }\n            map.items.pop()\n            return true\n        }\n    }\n    return false\n}\n\npub fn map_iter<K, V>(map: Map<K, V>) -> MapIterator<K, V> {\n    return MapIterator<K, V>{ items: map.items, index: 0 }\n}\n\npub fn map_iter_has_next<K, V>(it: MapIterator<K, V>) -> bool {\n    return it.index < len(it.items)\n}\n\npub fn map_iter_next<K, V>(it: MapIterator<K, V>) -> Entry<K, V> {\n    let item = it.items[it.index]\n    it.index = it.index + 1\n    return item\n}\n\npub fn map_keys<K, V>(map: Map<K, V>) -> [K] {\n    let keys = []\n    for i in 0..len(map.items) {\n        let entry = map.items[i]\n        keys.push(entry.key)\n    }\n    return keys\n}\n\npub fn map_values<K, V>(map: Map<K, V>) -> [V] {\n    let values = []\n    for i in 0..len(map.items) {\n        let entry = map.items[i]\n        values.push(entry.value)\n    }\n    return values\n}\n\npub struct Set<T> {\n    items: [T]\n}\n\npub struct SetIterator<T> {\n    items: [T]\n    index: i32\n}\n\npub fn set_new<T>() -> Set<T> {\n    return Set<T>{ items: [] }\n}\n\npub fn set_contains<T: Comparable>(set: Set<T>, value: T) -> bool {\n    for i in 0..len(set.items) {\n        if set.items[i] == value {\n            return true\n        }\n    }\n    return false\n}\n\npub fn set_add<T: Comparable>(set: Set<T>, value: T) {\n    if not set_contains(set, value) {\n        set.items.push(value)\n    }\n}\n\npub fn set_remove<T: Comparable>(set: Set<T>, value: T) -> bool {\n    for i in 0..len(set.items) {\n        if set.items[i] == value {\n            let idx = i\n            for j in idx+1..len(set.items) {\n                set.items[j-1] = set.items[j]\n            }\n            set.items.pop()\n            return true\n        }\n    }\n    return false\n}\n\npub fn set_iter<T>(set: Set<T>) -> SetIterator<T> {\n    return SetIterator<T>{ items: set.items, index: 0 }\n}\n\npub fn set_iter_has_next<T>(it: SetIterator<T>) -> bool {\n    return it.index < len(it.items)\n}\n\npub fn set_iter_next<T>(it: SetIterator<T>) -> T {\n    let item = it.items[it.index]\n    it.index = it.index + 1\n    return item\n}\n\npub struct ArrayIterator<T> {\n    items: [T]\n    index: i32\n}\n\npub fn iter<T>(arr: [T]) -> ArrayIterator<T> {\n    return ArrayIterator<T>{ items: arr, index: 0 }\n}\n\npub fn iter_has_next<T>(it: ArrayIterator<T>) -> bool {\n    return it.index < len(it.items)\n}\n\npub fn iter_next<T>(it: ArrayIterator<T>) -> T {\n    let item = it.items[it.index]\n    it.index = it.index + 1\n    return item\n}\n\n"},
    {"std/datetime.orus", "// Standard datetime utilities inspired by Python\n\npub struct Date {\n    year: i32,\n    month: i32,\n    day: i32,\n}\n\npub struct Time {\n    hour: i32,\n    minute: i32,\n    second: i32,\n    microsecond: i32,\n}\n\npub struct DateTime {\n    date: Date,\n    time: Time,\n}\n\npub struct TimeDelta {\n    seconds: i64,\n}\n\nfn is_leap_year(year: i32) -> bool {\n    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) {\n        return true\n    }\n    return false\n}\n\nfn days_in_month(year: i32, month: i32) -> i32 {\n    let days: [i32; 12] = [31,28,31,30,31,30,31,31,30,31,30,31]\n    let d = days[month - 1 as i32]\n    if month == 2 as i32 and is_leap_year(year) {\n        return 29 as i32\n    }\n    return d\n}\n\n// Convert a DateTime to seconds since the Unix epoch\npub fn timestamp(dt: DateTime) -> f64 {\n    let mut days: i64 = 0\n    let mut y: i32 = 1970\n    while y < dt.date.year {\n        if is_leap_year(y) {\n            days = days + 366\n        } else {\n            days = days + 365\n        }\n        y = y + 1 as i32\n    }\n    let mut m: i32 = 1\n    while m < dt.date.month {\n        days = days + (days_in_month(dt.date.year, m) as i64)\n        m = m + 1 as i32\n    }\n    days = days + (dt.date.day - 1 as i32)\n    let secs: i64 = days * 86400 + (dt.time.hour as i64) * 3600 + (dt.time.minute as i64) * 60 + dt.time.second as i64\n    return (secs as f64) + (dt.time.microsecond as f64) / 1000000.0\n}\n\n// Build a DateTime from a Unix timestamp (seconds since epoch)\npub fn from_timestamp(ts: f64) -> DateTime {\n    let mut seconds: i64 = ts as i64\n    let frac: f64 = ts - (seconds as f64)\n    let micro: i32 = (frac * 1000000.0) as i32\n    let second: i32 = (seconds % 60) as i32\n    let minute: i32 = ((seconds / 60) % 60) as i32\n    let hour: i32 = ((seconds / 3600) % 24) as i32\n    let mut days: i64 = seconds / 86400\n    let mut year: i32 = 1970\n    while true {\n        let mut year_days: i64 = 365 as i64\n        if is_leap_year(year) {\n            year_days = 366 as i64\n        }\n        if days >= year_days {\n            days = days - year_days\n            year = year + 1 as i32\n        } else {\n            break\n        }\n    }\n    let mut month: i32 = 1\n    while true {\n        let dim: i64 = days_in_month(year, month) as i64\n        if days >= dim {\n            days = days - dim\n            month = month + 1 as i32\n        } else {\n            break\n        }\n    }\n    let day: i32 = (days + 1) as i32\n    return DateTime{\n        date: Date{ year: year, month: month, day: day },\n        time: Time{ hour: hour, minute: minute, second: second, microsecond: micro },\n    }\n}\n\npub fn now() -> DateTime {\n    return from_timestamp(timestamp() as f64)\n}\n\npub fn utcnow() -> DateTime {\n    return from_timestamp(timestamp() as f64)\n}\n\nfn pad2(n: i32) -> string {\n    return n < (10 as i32) ? \"0\" + n : \"\" + n\n}\n\nfn pad4(n: i32) -> string {\n    return n < (10 as i32) ? \"000\" + n : n < (100 as i32) ? \"00\" + n : n < (1000 as i32) ? \"0\" + n : \"\" + n\n}\n\nfn pad6(n: i32) -> string {\n    return n < (10 as i32) ? \"00000\" + n : n < (100 as i32) ? \"0000\" + n : n < (1000 as i32) ? \"000\" + n : n < (10000 as i32) ? \"00\" + n : n < (100000 as i32) ? \"0\" + n : \"\" + n\n}\n\n// Basic strftime style formatting supporting %Y %m %d %H %M %S\npub fn format(dt: DateTime, fmt: string) -> string {\n    let mut out = \"\"\n    let mut i: i32 = 0\n    while i < len(fmt) {\n        let ch = substring(fmt, i, 1 as i32)\n        if ch == \"%\" {\n            let code = substring(fmt, i + 1 as i32, 1 as i32)\n            out = out + (\n                code == \"Y\" ? pad4(dt.date.year)\n                : code == \"m\" ? pad2(dt.date.month)\n                : code == \"d\" ? pad2(dt.date.day)\n                : code == \"H\" ? pad2(dt.time.hour)\n                : code == \"M\" ? pad2(dt.time.minute)\n                : code == \"S\" ? pad2(dt.time.second)\n                : code == \"f\" ? pad6(dt.time.microsecond)\n                : code\n            )\n            i = i + 2 as i32\n        } else {\n            out = out + ch\n            i = i + 1 as i32\n        }\n    }\n    return out\n}\n\n// Parse a datetime string according to the given format\npub fn parse(text: string, fmt: string) -> DateTime {\n    let mut year: i32 = 1970\n    let mut month: i32 = 1\n    let mut day: i32 = 1\n    let mut hour: i32 = 0\n    let mut minute: i32 = 0\n    let mut second: i32 = 0\n    let mut micro: i32 = 0\n    let mut i_fmt: i32 = 0\n    let mut i_txt: i32 = 0\n    while i_fmt < len(fmt) {\n        let ch = substring(fmt, i_fmt, 1 as i32)\n        if ch == \"%\" {\n            let code = substring(fmt, i_fmt + 1 as i32, 1 as i32)\n            if code == \"Y\" {\n                let part = substring(text, i_txt, 4 as i32)\n                year = int(part)\n                i_txt = i_txt + 4 as i32\n            } else {\n                let segLen: i32 = code == \"f\" ? 6 as i32 : 2 as i32\n                let part = substring(text, i_txt, segLen)\n                let val = int(part)\n                if code == \"m\" {\n                    month = val\n                } elif code == \"d\" {\n                    day = val\n                } elif code == \"H\" {\n                    hour = val\n                } elif code == \"M\" {\n                    minute = val\n                } elif code == \"S\" {\n                    second = val\n                } elif code == \"f\" {\n                    micro = val\n                }\n                i_txt = i_txt + segLen\n            }\n            i_fmt = i_fmt + 2 as i32\n        } else {\n            i_fmt = i_fmt + 1 as i32\n            i_txt = i_txt + 1 as i32\n        }\n    }\n    return DateTime{\n        date: Date{ year: year, month: month, day: day },\n        time: Time{ hour: hour, minute: minute, second: second, microsecond: micro },\n    }\n}\n\npub fn date(dt: DateTime) -> Date {\n    return dt.date\n}\n\npub fn time(dt: DateTime) -> Time {\n    return dt.time\n}\n\npub fn to_string(dt: DateTime) -> string {\n    let base = format(dt, \"%Y-%m-%d %H:%M:%S\")\n    return dt.time.microsecond != 0 as i32 ? base + \".\" + pad6(dt.time.microsecond) : base\n}\n\npub fn DateTime_to_string(dt: DateTime) -> string {\n    return to_string(dt)\n}\n\nimpl DateTime {\n    fn to_string(self) -> string {\n        return to_string(self)\n    }\n}\n\n"},
    {"std/random.orus", "\n// Linear Congruential Generator state\nstatic mut SEED: u64 = 123456789u\n\nfn rand_u64() -> u64 {\n    // Update the global seed using LCG parameters\n    SEED = ((SEED as i64 * 6364136223846793005 + 1) as u64)\n    return SEED\n}\n\n// Set the seed for reproducible sequences\npub fn set_seed(seed: u64) {\n    SEED = seed\n}\n\n// Automatically seed the generator when the module is loaded\nset_seed(timestamp() as u64)\n\n// Return a float in the range [0.0, 1.0)\npub fn random() -> f64 {\n    // Divide by 2^64-1 to map to [0,1)\n    return (rand_u64() as f64) / 18446744073709551615.0\n}\n\n// Return an integer in [min, max]\npub fn randint(min: i32, max: i32) -> i32 {\n    let r: f64 = random()\n    let range: f64 = (max - min + 1) as f64\n    let offset: i32 = (r * range) as i32\n    return min + offset\n}\n\n// Return a float in [a, b]\npub fn uniform(a: f64, b: f64) -> f64 {\n    return a + (b - a) * random()\n}\n\n// Choose a random element from the array\npub fn choice<T>(arr: [T]) -> T {\n    let i = randint(0 as i32, len(arr) - 1 as i32)\n    return arr[i]\n}\n\n// Shuffle the array in-place using Fisher-Yates\npub fn shuffle<T>(arr: [T]) {\n    let n = len(arr)\n    for i in 0 as i32..n {\n        let j = randint(i, n - 1 as i32)\n        let temp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = temp\n    }\n}\n\n// Return k unique elements sampled from the array\npub fn sample<T>(arr: [T], k: i32) -> [T] {\n    let copy: [T; 0] = arr[..]\n    shuffle(copy)\n    return copy[0 as i32..k]\n}\n\n// TODO: additional distributions like gauss require math.log/cos/sin\n"},
    {"std/math.orus", "pub const PI: f64 = 3.141592653589793\npub const E: f64 = 2.718281828459045\npub const TAU: f64 = 6.283185307179586\n\npub fn abs<T: Numeric>(x: T) -> T {\n    let zero = x - x\n    if x < zero {\n        return -x\n    }\n    return x\n}\n\npub fn clamp<T: Comparable>(x: T, min_val: T, max_val: T) -> T {\n    if x < min_val {\n        return min_val\n    }\n    if x > max_val {\n        return max_val\n    }\n    return x\n}\n\npub fn pow(base: f64, exponent: i32) -> f64 {\n    let mut b = base\n    let mut e = exponent\n    let mut result: f64 = 1.0\n    if e < (0 as i32) {\n        b = 1.0 / b\n        e = -e\n    }\n    while e > (0 as i32) {\n        if (e & (1 as i32)) == (1 as i32) {\n            result = result * b\n        }\n        e = e >> (1 as i32)\n        b = b * b\n    }\n    return result\n}\n\npub fn sqrt(x: f64) -> f64 {\n    if x <= 0.0 {\n        return 0.0\n    }\n    let mut guess = x / 2.0\n    let mut last = 0.0\n    while abs(guess - last) > 0.0000001 {\n        last = guess\n        guess = (guess + x / guess) / 2.0\n    }\n    return guess\n}\n\npub fn floor(x: f64) -> i32 {\n    let i: i32 = x as i32\n    if x < 0.0 and (x != (i as f64)) {\n        return i - 1 as i32\n    }\n    return i\n}\n\npub fn ceil(x: f64) -> i32 {\n    let i: i32 = x as i32\n    if x > 0.0 and (x != (i as f64)) {\n        return i + 1 as i32\n    }\n    return i\n}\n\npub fn round(x: f64) -> i32 {\n    return floor(x + 0.5)\n}\n\npub fn sign<T: Numeric>(x: T) -> i32 {\n    let zero = x - x\n    if x > zero {\n        return 1 as i32\n    }\n    if x < zero {\n        return -1 as i32\n    }\n    return 0 as i32\n}\n\npub fn average(values: [f64]) -> f64 {\n    if len(values) == 0 as i32 {\n        return 0.0\n    }\n    return sum(values) / (len(values) as f64)\n}\n\npub fn median(values: [f64]) -> f64 {\n    if len(values) == 0 as i32 {\n        return 0.0\n    }\n    let sortedVals = sorted(values)\n    let mid: i32 = len(sortedVals) / 2 as i32\n    if (len(sortedVals) & (1 as i32)) == 1 as i32 {\n        return sortedVals[mid]\n    }\n    return (sortedVals[mid - 1 as i32] + sortedVals[mid]) / 2.0\n}\n\npub fn mod<T: Numeric>(a: T, b: T) -> T {\n    let mut r = a % b\n    let zero = a - a\n    if r < zero {\n        r = r + b\n    }\n    return r\n}\n"},
};
const int embeddedStdlibCount = sizeof(embeddedStdlib)/sizeof(EmbeddedModule);

const char* getEmbeddedModule(const char* name){
    for(int i=0;i<embeddedStdlibCount;i++){
        if(strcmp(embeddedStdlib[i].name,name)==0) return embeddedStdlib[i].source;
    }
    return NULL;
}

static void ensure_dir(const char* path){
    char tmp[512];
    strncpy(tmp,path,sizeof(tmp)-1);
    tmp[sizeof(tmp)-1]=0;
    for(char* p=tmp+1; *p; p++){ if(*p=='/'){ *p=0; mkdir(tmp,0755); *p='/'; } }
    mkdir(tmp,0755);
}

void dumpEmbeddedStdlib(const char* dir){
    char full[512];
    for(int i=0;i<embeddedStdlibCount;i++){
        snprintf(full,sizeof(full),"%s/%s",dir,embeddedStdlib[i].name);
        char* slash=strrchr(full,'/');
        if(slash){ *slash=0; ensure_dir(full); *slash='/'; } else { ensure_dir(full); }
        FILE* f=fopen(full,"w"); if(f){ fputs(embeddedStdlib[i].source,f); fclose(f); }
    }
}
