// Generic type constraints test (syntax may not be supported yet)
fn add_numeric<T: Numeric>(a: T, b: T) -> T {
    return a + b
}

fn compare<T: Comparable>(a: T, b: T) -> bool {
    return a > b
}

fn sort_array<T: Comparable>(arr: [T]) -> [T] {
    // Simple bubble sort for demonstration
    let len = len(arr)
    for i in 0..len {
        for j in 0..(len - i - 1) {
            if arr[j] > arr[j + 1] {
                let temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
        }
    }
    return arr
}

fn main() {
    // Test numeric constraint
    let sum_int = add_numeric<i32>(10, 20)
    print("add_numeric<i32>(10, 20) = {}", sum_int)
    
    let sum_float = add_numeric<f64>(3.14, 2.86)
    print("add_numeric<f64>(3.14, 2.86) = {}", sum_float)
    
    // Test comparable constraint
    let greater = compare<i32>(15, 10)
    print("compare<i32>(15, 10) = {}", greater)
    
    let str_greater = compare<string>("world", "hello")
    print("compare<string>(\"world\", \"hello\") = {}", str_greater)
    
    // Test generic array sorting
    let numbers = [3, 1, 4, 1, 5, 9, 2, 6]
    let sorted_numbers = sort_array<i32>(numbers)
    print("sorted numbers: {}", sorted_numbers)
    
    let words = ["zebra", "apple", "banana", "cherry"]
    let sorted_words = sort_array<string>(words)
    print("sorted words: {}", sorted_words)
}