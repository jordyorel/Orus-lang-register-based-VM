// Performance tests for the new array implementation
// Tests memory efficiency, growth patterns, and operation speed

fn test_growth_performance() {
    print("=== Array Growth Performance Test ===")
    
    let arr: [i32] = []
    print("Starting with empty array")
    
    // Test growth pattern - should double capacity
    print("Testing dynamic growth with 1000 push operations...")
    
    for i in 0..1000 {
        arr.push(i)
        
        // Print capacity info at key growth points
        if i == 7 || i == 15 || i == 31 || i == 63 || i == 127 || i == 255 || i == 511 {
            print("After {} pushes, length: {}", i + 1, len(arr))
        }
    }
    
    print("Final array length: {}", len(arr))
    print("First element: {}", arr[0])
    print("Last element: {}", arr[-1])
    print("Middle element: {}", arr[500])
}

fn test_access_performance() {
    print("=== Array Access Performance Test ===")
    
    // Create large array
    let large: [i32] = []
    for i in 0..500 {
        large.push(i * 2)
    }
    
    print("Created array with 500 elements")
    
    // Test random access performance
    print("Testing random access...")
    print("Element at index 0: {}", large[0])
    print("Element at index 100: {}", large[100])
    print("Element at index 250: {}", large[250])
    print("Element at index 499: {}", large[499])
    
    // Test negative indexing performance
    print("Testing negative indexing...")
    print("Element at index -1: {}", large[-1])
    print("Element at index -100: {}", large[-100])
    print("Element at index -250: {}", large[-250])
    print("Element at index -500: {}", large[-500])
}

fn test_modification_performance() {
    print("=== Array Modification Performance Test ===")
    
    let arr: [i32] = []
    
    // Fill array
    for i in 0..100 {
        arr.push(i)
    }
    
    print("Created array with 100 elements")
    
    // Test bulk modification
    print("Testing bulk modification...")
    for i in 0..100 {
        arr[i] = arr[i] * 2
    }
    
    print("Modified all elements")
    print("First few elements: {}, {}, {}", arr[0], arr[1], arr[2])
    print("Last few elements: {}, {}, {}", arr[-3], arr[-2], arr[-1])
}

fn test_push_pop_performance() {
    print("=== Push/Pop Performance Test ===")
    
    let stack: [i32] = []
    
    // Test push performance
    print("Testing push performance (100 operations)...")
    for i in 0..100 {
        stack.push(i)
    }
    print("Pushed 100 elements, length: {}", len(stack))
    
    // Test pop performance
    print("Testing pop performance...")
    let sum = 0
    while len(stack) > 0 {
        sum = sum + stack.pop()
    }
    
    print("Popped all elements, sum: {}", sum)
    print("Final length: {}", len(stack))
}

fn test_memory_efficiency() {
    print("=== Memory Efficiency Test ===")
    
    // Test that arrays don't waste excessive memory
    let small: [i32] = [1, 2, 3]
    print("Small array (3 elements): {}", small)
    print("Length: {}", len(small))
    
    // Test that growth is reasonable
    let growing: [i32] = []
    for i in 0..10 {
        growing.push(i)
    }
    print("After 10 pushes: {}", growing)
    print("Length: {}", len(growing))
    
    // Test that empty arrays are efficient
    let empty: [i32] = []
    print("Empty array: {}", empty)
    print("Empty length: {}", len(empty))
}

fn main() {
    print("⚡ ARRAY PERFORMANCE TEST SUITE")
    print("Testing performance characteristics of new array implementation")
    print("")
    
    test_growth_performance()
    print("")
    
    test_access_performance()
    print("")
    
    test_modification_performance()
    print("")
    
    test_push_pop_performance()
    print("")
    
    test_memory_efficiency()
    print("")
    
    print("✅ All performance tests completed!")
    print("Array implementation shows good performance characteristics!")
}