// Error handling tests for array implementation
// Tests bounds checking, type safety, and error conditions

fn test_bounds_errors() {
    print("=== Testing Array Bounds Errors ===")
    
    let arr: [i32] = [1, 2, 3]
    print("Test array: {}", arr)
    print("Array length: {}", len(arr))
    
    // Test positive out of bounds
    print("Testing positive index out of bounds...")
    try {
        let val = arr[3]  // Should fail - index 3 in array of length 3
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected error: {}", error)
    }
    
    try {
        let val = arr[100]  // Way out of bounds
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected error: {}", error)
    }
    
    // Test negative out of bounds
    print("Testing negative index out of bounds...")
    try {
        let val = arr[-4]  // Should fail - beyond start of array
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected error: {}", error)
    }
    
    try {
        let val = arr[-100]  // Way out of bounds negative
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected error: {}", error)
    }
}

fn test_assignment_bounds_errors() {
    print("=== Testing Array Assignment Bounds Errors ===")
    
    let arr: [i32] = [10, 20, 30]
    print("Test array: {}", arr)
    
    // Test assignment out of bounds
    try {
        arr[3] = 40  // Should fail
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected assignment error: {}", error)
    }
    
    try {
        arr[-4] = 5  // Should fail
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected negative assignment error: {}", error)
    }
    
    // Verify array unchanged
    print("Array after failed assignments: {}", arr)
}

fn test_empty_array_errors() {
    print("=== Testing Empty Array Errors ===")
    
    let empty: [i32] = []
    print("Empty array: {}", empty)
    print("Empty array length: {}", len(empty))
    
    // Test accessing empty array
    try {
        let val = empty[0]  // Should fail
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected empty array access error: {}", error)
    }
    
    try {
        let val = empty[-1]  // Should fail
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected empty array negative access error: {}", error)
    }
    
    // Test popping from empty array
    try {
        let val = empty.pop()  // Should fail
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught expected empty array pop error: {}", error)
    }
}

fn test_type_safety_errors() {
    print("=== Testing Array Type Safety ===")
    
    let arr: [i32] = [1, 2, 3]
    
    // Test using non-integer as index
    try {
        // This would be caught at compile-time in a strongly typed system
        // For now, we test runtime type checking
        print("Testing type safety in indexing...")
        print("Note: Type safety for indices should be enforced")
        
        // Valid access to show contrast
        print("Valid access: arr[0] = {}", arr[0])
        
    } catch error {
        print("Caught type safety error: {}", error)
    }
}

fn test_negative_capacity_error() {
    print("=== Testing Negative Capacity Error ===")
    
    // This would test ROP_ARRAY_NEW with negative capacity
    // In practice, this is handled by the array creation logic
    print("Testing array creation with reasonable parameters...")
    
    let normal_arr: [i32] = []
    print("Created normal array: {}", normal_arr)
    
    // Add some elements to verify it works
    normal_arr.push(1)
    normal_arr.push(2)
    print("After adding elements: {}", normal_arr)
}

fn test_edge_case_indices() {
    print("=== Testing Edge Case Indices ===")
    
    let arr: [i32] = [100]  // Single element array
    print("Single element array: {}", arr)
    
    // Test valid accesses
    print("arr[0] = {}", arr[0])
    print("arr[-1] = {}", arr[-1])
    
    // Test edge case bounds
    try {
        let val = arr[1]  // Just out of bounds
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught edge case error: {}", error)
    }
    
    try {
        let val = arr[-2]  // Just out of bounds negative
        print("ERROR: Should not reach here")
    } catch error {
        print("âœ… Caught negative edge case error: {}", error)
    }
}

fn main() {
    print("ðŸš¨ ARRAY ERROR HANDLING TEST SUITE")
    print("Testing bounds checking and error conditions")
    print("Note: All errors should be caught gracefully")
    print("")
    
    test_bounds_errors()
    print("")
    
    test_assignment_bounds_errors()
    print("")
    
    test_empty_array_errors()
    print("")
    
    test_type_safety_errors()
    print("")
    
    test_negative_capacity_error()
    print("")
    
    test_edge_case_indices()
    print("")
    
    print("âœ… All error handling tests completed!")
    print("Array implementation properly handles error conditions!")
}