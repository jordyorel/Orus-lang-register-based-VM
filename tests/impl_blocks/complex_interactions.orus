# Complex Interactions Test
# Tests complex scenarios with method calls, struct nesting, and advanced patterns

struct Vector2D {
    x: f64,
    y: f64,
}

impl Vector2D {
    fn new(x: f64, y: f64) -> Vector2D {
        return Vector2D { x: x, y: y }
    }
    
    fn magnitude(self) -> f64 {
        return sqrt(self.x * self.x + self.y * self.y)
    }
    
    fn normalize(self) -> Vector2D {
        let mag: f64 = self.magnitude()
        if mag == 0.0 {
            return Vector2D.new(0.0, 0.0)
        }
        return Vector2D.new(self.x / mag, self.y / mag)
    }
    
    fn add(self, other: Vector2D) -> Vector2D {
        return Vector2D.new(self.x + other.x, self.y + other.y)
    }
    
    fn dot_product(self, other: Vector2D) -> f64 {
        return self.x * other.x + self.y * other.y
    }
    
    fn scale(self, factor: f64) -> Vector2D {
        return Vector2D.new(self.x * factor, self.y * factor)
    }
    
    fn distance_to(self, other: Vector2D) -> f64 {
        let diff: Vector2D = self.subtract(other)
        return diff.magnitude()
    }
    
    fn subtract(self, other: Vector2D) -> Vector2D {
        return Vector2D.new(self.x - other.x, self.y - other.y)
    }
    
    fn to_string(self) -> string {
        return "({}, {})"
    }
}

struct Circle {
    center: Vector2D,
    radius: f64,
}

impl Circle {
    fn new(center: Vector2D, radius: f64) -> Circle {
        return Circle { center: center, radius: radius }
    }
    
    fn area(self) -> f64 {
        return 3.14159 * self.radius * self.radius
    }
    
    fn circumference(self) -> f64 {
        return 2.0 * 3.14159 * self.radius
    }
    
    fn contains_point(self, point: Vector2D) -> bool {
        let distance: f64 = self.center.distance_to(point)
        return distance <= self.radius
    }
    
    fn overlaps_with(self, other: Circle) -> bool {
        let distance: f64 = self.center.distance_to(other.center)
        return distance <= (self.radius + other.radius)
    }
    
    fn move_by(self, offset: Vector2D) {
        self.center = self.center.add(offset)
    }
    
    fn scale_radius(self, factor: f64) {
        self.radius = self.radius * factor
    }
    
    fn get_point_on_circle(self, angle: f64) -> Vector2D {
        let x: f64 = self.center.x + self.radius * cos(angle)
        let y: f64 = self.center.y + self.radius * sin(angle)
        return Vector2D.new(x, y)
    }
}

struct GameObject {
    position: Vector2D,
    velocity: Vector2D,
    name: string,
}

impl GameObject {
    fn new(name: string, x: f64, y: f64) -> GameObject {
        return GameObject {
            name: name,
            position: Vector2D.new(x, y),
            velocity: Vector2D.new(0.0, 0.0),
        }
    }
    
    fn set_velocity(self, vx: f64, vy: f64) {
        self.velocity = Vector2D.new(vx, vy)
    }
    
    fn update(self, delta_time: f64) {
        let movement: Vector2D = self.velocity.scale(delta_time)
        self.position = self.position.add(movement)
    }
    
    fn distance_to(self, other: GameObject) -> f64 {
        return self.position.distance_to(other.position)
    }
    
    fn get_speed(self) -> f64 {
        return self.velocity.magnitude()
    }
    
    fn stop(self) {
        self.velocity = Vector2D.new(0.0, 0.0)
    }
    
    fn accelerate(self, acceleration: Vector2D, delta_time: f64) {
        let accel_scaled: Vector2D = acceleration.scale(delta_time)
        self.velocity = self.velocity.add(accel_scaled)
    }
    
    fn describe(self) -> string {
        return "{} at {} with velocity {}"
    }
}

fn main() {
    print("=== Vector2D Tests ===")
    
    # Test basic vector operations
    let v1: Vector2D = Vector2D.new(3.0, 4.0)
    let v2: Vector2D = Vector2D.new(1.0, 2.0)
    
    print("v1: {}", v1.to_string())
    print("v1 magnitude: {}", v1.magnitude())
    
    let v1_normalized: Vector2D = v1.normalize()
    print("v1 normalized: {}", v1_normalized.to_string())
    
    let v_sum: Vector2D = v1.add(v2)
    print("v1 + v2: {}", v_sum.to_string())
    
    let dot: f64 = v1.dot_product(v2)
    print("v1 Â· v2: {}", dot)
    
    print("\n=== Circle Tests ===")
    
    # Test circle with vector operations
    let center: Vector2D = Vector2D.new(0.0, 0.0)
    let circle1: Circle = Circle.new(center, 5.0)
    
    print("Circle area: {}", circle1.area())
    print("Circle circumference: {}", circle1.circumference())
    
    let test_point: Vector2D = Vector2D.new(3.0, 3.0)
    print("Point {} is inside circle: {}", test_point.to_string(), circle1.contains_point(test_point))
    
    let circle2: Circle = Circle.new(Vector2D.new(8.0, 0.0), 3.0)
    print("Circles overlap: {}", circle1.overlaps_with(circle2))
    
    # Move circle and test again
    circle2.move_by(Vector2D.new(-3.0, 0.0))
    print("After moving circle2, circles overlap: {}", circle1.overlaps_with(circle2))
    
    print("\n=== GameObject Tests ===")
    
    # Test complex game object interactions
    let player: GameObject = GameObject.new("Player", 0.0, 0.0)
    let enemy: GameObject = GameObject.new("Enemy", 10.0, 0.0)
    
    player.set_velocity(2.0, 1.0)
    enemy.set_velocity(-1.0, 0.0)
    
    print("Initial distance: {}", player.distance_to(enemy))
    print("Player speed: {}", player.get_speed())
    print("Player: {}", player.describe())
    
    # Simulate movement
    let delta: f64 = 1.0
    player.update(delta)
    enemy.update(delta)
    
    print("After 1 second:")
    print("Distance: {}", player.distance_to(enemy))
    print("Player: {}", player.describe())
    
    # Test acceleration
    let gravity: Vector2D = Vector2D.new(0.0, -9.8)
    player.accelerate(gravity, delta)
    
    print("After applying gravity:")
    print("Player speed: {}", player.get_speed())
    print("Player: {}", player.describe())
    
    # Expected output shows complex interactions between 
    # nested structs and method calls across different types
}