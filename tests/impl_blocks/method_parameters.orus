# Method Parameters Test
# Tests methods with various parameter combinations and types

struct Container {
    items: [string],
    capacity: i32,
}

impl Container {
    fn new(capacity: i32) -> Container {
        let empty_items: [string] = []
        return Container { items: empty_items, capacity: capacity }
    }
    
    # Method with no parameters (except self)
    fn size(self) -> i32 {
        return len(self.items)
    }
    
    # Method with one parameter
    fn add_item(self, item: string) {
        if self.size() < self.capacity {
            self.items.push(item)
        }
    }
    
    # Method with multiple parameters
    fn add_multiple(self, item1: string, item2: string, item3: string) {
        self.add_item(item1)
        self.add_item(item2)
        self.add_item(item3)
    }
    
    # Method with mixed parameter types
    fn add_numbered_item(self, item: string, number: i32, is_important: bool) {
        let prefix: string = ""
        if is_important {
            prefix = "IMPORTANT: "
        }
        let full_item: string = "{}{} #{}"
        self.add_item(full_item)
    }
    
    # Method returning complex result
    fn get_item_at(self, index: i32) -> string {
        if index >= 0 && index < self.size() {
            return self.items[index]
        }
        return "INDEX_OUT_OF_BOUNDS"
    }
    
    # Method with multiple return possibilities
    fn find_item(self, search: string) -> i32 {
        for i in 0..self.size() {
            if self.items[i] == search {
                return i
            }
        }
        return -1  # Not found
    }
    
    # Method with boolean parameter for different behavior
    fn list_items(self, numbered: bool) -> string {
        let result: string = ""
        for i in 0..self.size() {
            if numbered {
                result = result + "{}. {}\n"
            } else {
                result = result + "- {}\n"
            }
        }
        return result
    }
    
    fn is_full(self) -> bool {
        return self.size() >= self.capacity
    }
    
    fn remaining_space(self) -> i32 {
        return self.capacity - self.size()
    }
}

fn main() {
    # Create container
    let container: Container = Container.new(5)
    
    # Test method with no parameters
    print("Initial size: {}", container.size())
    print("Is full: {}", container.is_full())
    print("Remaining space: {}", container.remaining_space())
    
    # Test method with one parameter
    container.add_item("apple")
    container.add_item("banana")
    print("After adding 2 items, size: {}", container.size())
    
    # Test method with multiple parameters
    container.add_multiple("orange", "grape", "kiwi")
    print("After adding 3 more items, size: {}", container.size())
    print("Now is full: {}", container.is_full())
    
    # Test method with mixed parameter types
    let new_container: Container = Container.new(10)
    new_container.add_numbered_item("task", 1, true)
    new_container.add_numbered_item("reminder", 2, false)
    
    # Test method returning value
    print("First item in container: {}", container.get_item_at(0))
    print("Third item in container: {}", container.get_item_at(2))
    print("Invalid index: {}", container.get_item_at(10))
    
    # Test method with search
    let apple_index: i32 = container.find_item("apple")
    let missing_index: i32 = container.find_item("cherry")
    print("Apple found at index: {}", apple_index)
    print("Cherry found at index: {}", missing_index)
    
    # Test method with boolean parameter
    print("Unnumbered list:\n{}", container.list_items(false))
    print("Numbered list:\n{}", container.list_items(true))
    
    # Expected output:
    # Initial size: 0
    # Is full: false
    # Remaining space: 5
    # After adding 2 items, size: 2
    # After adding 3 more items, size: 5
    # Now is full: true
    # First item in container: apple
    # Third item in container: orange
    # Invalid index: INDEX_OUT_OF_BOUNDS
    # Apple found at index: 0
    # Cherry found at index: -1
    # Unnumbered list:
    # - apple
    # - banana
    # - orange
    # - grape
    # - kiwi
    #
    # Numbered list:
    # 1. apple
    # 2. banana
    # 3. orange
    # 4. grape
    # 5. kiwi
}