// Nested enum test
enum Inner {
    Value(i32),
    Empty
}

enum Outer {
    Contains(Inner),
    Nothing
}

enum Complex {
    Simple(i32),
    Nested(Outer),
    Multiple(Inner, Inner)
}

fn process_inner(inner: Inner) -> string {
    match inner {
        Inner.Value(val) => {
            return "Inner value: {}".format(val)
        }
        Inner.Empty => {
            return "Inner is empty"
        }
    }
}

fn process_outer(outer: Outer) -> string {
    match outer {
        Outer.Contains(inner) => {
            return "Outer contains: {}".format(process_inner(inner))
        }
        Outer.Nothing => {
            return "Outer contains nothing"
        }
    }
}

fn process_complex(complex: Complex) {
    match complex {
        Complex.Simple(val) => {
            print("Simple: {}", val)
        }
        Complex.Nested(outer) => {
            print("Nested: {}", process_outer(outer))
        }
        Complex.Multiple(inner1, inner2) => {
            print("Multiple: {} and {}", process_inner(inner1), process_inner(inner2))
        }
    }
}

fn main() {
    let inner1 = Inner.Value(42)
    let inner2 = Inner.Empty
    
    let outer1 = Outer.Contains(inner1)
    let outer2 = Outer.Nothing
    
    let complex_cases = [
        Complex.Simple(100),
        Complex.Nested(outer1),
        Complex.Nested(outer2),
        Complex.Multiple(Inner.Value(10), Inner.Value(20)),
        Complex.Multiple(Inner.Empty, Inner.Value(30))
    ]
    
    for complex in complex_cases {
        process_complex(complex)
    }
}